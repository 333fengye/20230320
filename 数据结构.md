# 时间复杂度与空间复杂度

- 时间复杂度
    - 运行的总次数
        - 代码结构
            - 算法(流程)
            - 数据结构
- 空间复杂度
    - 额外消耗的空间
        - 数据结构的选择
- 复杂度计算：渐进符号O()
    - 多项式级的运算结果，只保留最高次幂
    - 去掉常数项系数
    - 如果程序在有限可数的资源内完成，复杂度为O(1)
- 一些例子
    - for(int i = 0;i<n;i= i*2);这个时间复杂度为log(2,n)
    - 三层for循环，时间复杂度为O(n^3)
    - 两层为O(n^2)
- 总结
    - 单纯的顺序或者选择结构，时间复杂度为O(1)
    - 一般情况下的一层循环时间复杂度为O(n)
    - 一般情况下，两层嵌套循环的时间复杂度为O(n^2)
    - 顺序执行的两个循环，时间复杂度为O(max(n,m))
    - 空间换时间一般算法有递归，分治，动态规划等方法降低时间复杂度
- worst,average,best(boges)

# 数据结构:数据存储和运算

### 线性结构	

- 顺序存储
    - arrray(一维数组)
        - 定义：类型相同，空间连续，长度固定
        - 增删改查
            - 增删
                - 空间够
                    - 末尾
                        - 直接加或者删除
                    - 头或者中间
                        - 后面的数据需要整体移动，O(n)
                - 空间不够
                    - 需要扩容
            - 改查
                - Index：O(1)
                - value
                    - 无序：O(n)
                        - 1遍O(n)
                        - 反复搜索：Hashtable：O(1)
                    - 有序：O(log(2,n))
        - 优劣势
            - 劣势
                - 因为长度固定，空间不够时需要扩容，建立一个新的更大的数组然后把旧的复制过去，O(n)
            - 优势
                - 查找快捷
        - n个元素素，每个元素出现两次，有一个出现一次，找出出现一次的元素
            - 所有元素异或得到的数为出现一次的数
                - 相同的数异或为0
        - n个元素素，每个元素出现两次，有两个出现一次，找出出现一次的元素
            - 所有的数异或，得到的为两个单独出现的数的位置数不同的值，找到其中一个为一的数字，数组中的数与该数与，为零与不为零分成两组，两组中找出分别找出一个出现一次的数
        - int a[5] = {1,2,3,4,5};  *((int*)((int)&a+1))的值
            - 计算机为小端存储，&a为数组空间的首地址，(int)强转为int型，+1为数字+1，(int*)该数字强转为int地址，在取出地址中的数值

 优点：(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组
        进行动态操作。通常体现在push_back() pop_back()
        (2) 随机访问方便，即支持[ ]操作符和vector.at()
        (3) 节省空间。
  缺点：(1) 在内部进行插入删除操作效率低。
        (2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。
        (3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释
           放

### 链式存储

- List
    - 单链表
        - 有头节点，数据域和指针域
            - 指针域存储下个节点的位置信息
        - 查找：O(n)
        - 增删改
            - 头部：O(1)
                - 新增节点先存储头节点中存储的下个节点信息，然后头节点存储新节点位置信息
            - 中间和尾部：O(n)：因为有查找的消耗
        - 特点：增删改灵活，对未知数据量可以处理，既可以增加长度
        - 单链表倒叙
            - 暴力：找到最后一个标记并打印，找到标记的上一个移动标记，打印
            - 递归
            - 压栈
            - 遍历链表头节点插入
            - 值放入数组
    - 跳跃链表(SkipList)服务于有序链表
        - 跳跃链表的增删改查为log（2，n）
        - 它有log（2，n）+1层
        - 每层的节点是否有下一层为随机，概率为1/2，上上一层还随机，直到没有
        - 新添加节点是否有上一层也随即，上上一层还随机，直到没有

  优点：(1) 不使用连续内存完成动态操作。
        (2) 在内部方便的进行插入和删除操作
        (3) 可在两端进行push、pop
  缺点：(1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()
        (2) 相对于verctor占用内存多

### stack

- 先进后出
- 可以用数组和链表实现
- 

### queue

### string

- 字符串
    - char* str1 = “hello”；char str2[] = "hello"；区别
        - str1为指针，str2为数字
            - str1 = “he”；可以，指针可以改变指向
            - str2 = “head”；不可以，str2为数组名，是一个常量，不可以改变
            - 因为类型不同，所以sizeof的得到的值不同
            - str1++ ，指针可以++
            - str2++，数组不行
        - 所在区域不同
            - str1指向常量区，只可读，不可写
            - str2在栈区，可读可写
    - 在形参中 [] ,退化为指针
    - 字符串相关函数
        - strcpy/strncpy
            - 字符串拷贝
            - 字符串局部拷贝
        - strsub
            - 返回从指定位置到指定长度的字符串
        - strcat/strncat
            - 字符串拼接
            - 字符串局部拼接
        - strlen
            - 获取长度
        - strcmp/strncmp
            - 字符串比较
            - 字符串局部比较
        - strstr
            - 一个字符串在另一个字符串中首次出现的位置
        - strtok
            - 截断
        - itoa(linux下没有)
            - 数字转字符串
        - atoi
            - 字符串转数字
        - sprintf
            - 字符串按照某个格式进行初始化
    - 字符串修改
        - 有一个字符串，然后用一个字符串替换掉其中的某个字符，如lunck替换空格，空间足够大
            - 获取空格的个数，绕后找到最后一个字符移动多少位，找到最后位置，标记，同时标记元字符位置，两者同时移动，遇到空格后后面的标记移动替换字符长度，然后两者再次同步移动，知道两者相遇代表替换完成
            - 截断，拼接
            - 暴力
    - 在字符串中找某个字符
    - 在字符串冲找某个字符串
        - strstr：找到某个字符串在这个字符串中首次出现的位置
            - KMP
                - 源：  abcabceabcabcdabcabcabcabcdabcabcfabc    匹配：abcabcdabcabcf
                    - 首先从开始a比较，比较到e，不同，这时我们发现匹配字符串失败位置前面有两个相等的部分，为abc，则源一样，这样我们可以用匹配中的第二个abc中a的位置与e比较，跳过前面的比较因为上面已经验证过了
                    - 
                    - 找到最大前缀与后缀相同长度
                        - 第一个位置为0，然后其他的让该元素与前一个的next值位置的元素比较，相等前一个加+1，不相等的话，将该元素当成这个位置的元素直到比较到相等或者为第一个元素时
            - Sunday
                - 
            - 前缀，后缀
                - 前缀：以第一个字符为首的子字符串（不包含整个字符串）
                - 后缀：以最后一个字符为尾的子字符串（不包含整个字符串）
                - abcad
                    - 前： a ab abc abca
                    - 后： d ad cad bcad
            - KMP
                - 对这个已经匹配过的字符串进行利用，匹配过的字符串看是否有在不考虑当前不匹配的字符的，最后一个匹配的字符最为尾部，到前面某一段是匹配字符串的前缀
                - 这个字符为尾的任何一部分不能再匹配字符串中与头相匹配，说明面前这些匹配过的已经不可能是答案了
                - 怎么看这个是呢，我们看这个不匹配字符前一个也就是匹配的最后一个字符，在匹配字符中，是否是字符串前缀中的某一个字符，不是那就不能成为答案是
                    - Next数组
                        - next数组是这个字符为末尾在前缀中的第几位
                        - 下标为零为0
                        - 其他：前面的为0，说明前面不是前缀中的，那就判断是不可以成为头部，不能0，能为1（成为一个前缀首部，后面的看他）
                        - 后面看前面有大佬是前缀中的看能不能成为其中的一员，他一看前面的和数为5，那说明他和第五个对应，也就是下标4，然后前面几个都可以是这个前缀中的
                        - 然后去看大佬后面的那个，也就是下标5，没错直接用这个数做下标，比较一看相等，他在大佬的基础上加1
                        - 不相等，他看这个不相等的数前面是否是这个大佬，是重复上述，是的，不是重复上述为零的
                - 是的话，对应前缀中的下一个与匹配字符匹配，重复上述过程
            - Sunday
                - 他比较以这个位置为开头的能不能成为答案，以看有匹配的，说明这一段不行，那么中间呢
                - 那么这个位置肯定不行了，要是中间有答案，那么这段的下一个字符，必定在这个匹配字符串中
                    - 数组记录最后每个字符最后出现的位置，创建256大小数组，初始值为-1，从头遍历，先出现的会被后出现的覆盖
                - 那么就找在匹配字符串中哪个出现了，最后出现的，比如abcdcdbcc，这个b，我们用第一个的话，前面这段中就一部分没考虑到
                - 然后我们以这个最后一个出现的字符为标准，找到头，两者从头匹配，直到又出现不匹配的了，重复上面，或者找到了
                - 不在匹配字符串中，说明这一大段都不可能是答案了
        - 找到符合条件的字符串
            - 比如：最长回文字符串，比如最长字典序字符串，最长无重复字符串等等
    - 在多个字符串找到某个字符串
    - 在两个字符串中公共部分
    - //字符串：char*，std::string,QString //char*是基础类型,std::string，QString都是封装的类 //char*可以直接给std::string,QString赋值 //std::string.c_str()=>char* //QString.toStdString()=>std::string

## 非线性结构：一对多或者多对多

### 树(一对多)

- 基本概念
    - 边联系的两个节点的关系：父子关系，上面为父节点，下面为孩子节点
    - 边：连接两个节点的为边
    - 根：根最上面的那个
    - 中间节点：有孩子节点的节点
    - 叶子节点：没有孩子节点的节点
    - 高度：仰视
    - 深度：俯视
    - 度：孩子节点数量
- 二叉树
    - BinaryTree:最多只有两个孩子
        - 二叉树基本特点
            - 一棵k层的二叉树，总的节点个数最多是2的k次方-1
            - 一颗k层的二叉树，总的叶子节点个数最多有2的（k-1）次方个
            - 任意一棵二叉树都满足，度为0的节点比度为2的节点多一个
        - 遍历方式
            - 深度遍历:栈
                - 前序遍历：根左右
                - 中序遍历：左根右
                - 后序遍历：左右根
            - 广度遍历/层序遍历：队列
    - 满二叉树：每一层都是满的
    - 完全二叉树：GBT：树中只有最后一层有空缺，并且空缺方式从右到左连续一直空缺
        - n个节点的GBT的高度/层数k = log（2，n）向下取整+1
        - 将一颗完全二叉树按照从上到下从左到右的顺序从1开始编号（1~n）                                           编号为i的节点：                                                    如果满足2*i < =n，编号为i的节点有左孩子，左孩子编号为2*i，否则没有；                                     如果满足2*i + 1<= n，编号为i的节点有右孩子，右孩子编号为2*i + 1，否则没有；                 父亲编号范围是1~n/2
        - 数组存储：下标为0~n-1；父节点小标为i：左孩子下表为i*2+1；右孩子下表为i*2+2；
    - 二叉搜索树：二叉排序树：BST：任意父亲节点的值均满足大于整颗左子树，小于整颗右子树
    - 旋转
        - 右旋
            - 由左的左引起的不平衡
                - 右旋，A的左变为E，B的右变为A，X的孩子变为B(讨论A在X的左侧还是右侧)，同时改变三个节点的父亲值
                    - 
        - 左旋
            - 由右的右引起的不平衡
                - 左旋，D变为A的右 ，A变为C的左，A的父亲孩子变为C(讨论A在X的左还是右)，同时改变三个节点的父亲值
                    - 
        - 左右旋
            - 由左的右引起的不平衡
                - 
        - 右左旋
            - 由右的左引起的不平衡

- ### 平衡搜索树

    - 二叉平衡搜索树：AVL树
        - 树中任意节点左右子树高度差不超过1

### 红黑树：RBT

- 性质
    - 每个节点不是红色的就是黑色的
    - 根节点必须是黑色的
    - 终端的NULL节点被认为是黑色的(黑哨兵)
    - 不允许两个红节点是父子关系
    - 从任意节点向下出发，到期所能达到的各个终端节点的各条路径上，黑节点的数目必须完全相同的
- 因为上面的五条性质的限制，红黑树上不会有一条路径的长度超过其他路径长度的两倍
- 红黑树的增删时间复杂度都是log(2,n)
- 添加
    - 新节点初始颜色：红色
    - 步骤
        - 查找
        - 空树
            - Z->B，成为root，结束
        - 非空树
            - 父为B
                - Z放入结束
            -  父为R
                - 叔为R
                    - 父->B，爷->R，叔->B，爷成为新Z，重新讨论
                - 叔为B
                    - 父在爷左侧
                        - Z在父的右侧
                            - 父成为新的Z，以Z为旋转点左旋
                        - Z在父的左侧
                            - 父->B，爷->R，以爷为旋转点右旋，结束
                    - 父在爷右侧
                        - Z在父的右侧
                            - 父->B，爷->R，以爷为旋转点左旋，结束
                        - Z在父的左侧
                            - 父成为新的Z，以Z为旋转点右旋
- 删除
    - 查找，找到被删除节点
    - 转变成删除度为0或度为1的节点
    - 删除讨论
        - 删除节点为根，没有孩子，删除根，树为空
        - 删除节点为根节点，有一个孩子，孩子变黑，删除根节点，孩子节点成为新的根节点
        - 删除节点为红色的节点，直接删除
        - 删除节点为度为1的黑色节点，孩子节点变为黑节点，删除节点的父亲指向删除节点的孩子（爷爷指向孩子），删除删除节点
        - 删除节点为非根无子的黑色节点
            - 兄弟是红的：兄弟变黑，父亲变红，以父为旋转点旋转
            - 兄弟是黑的
                - 两个侄子是黑的
                    - 父亲是红色的：父亲变为黑色，兄弟变为红色，结束
                    - 父亲是黑色的：兄弟变为红色，父亲成为新的讨论节点
                - 右侄为红，左侄为黑
                    - 兄弟在父亲的左侧
                        - 兄弟变红，右侄变黑，以兄弟为旋转点左旋
                    - 兄弟在父亲的右侧
                        - 父亲的颜色给兄的，父亲变为黑色，右侄变为黑色，以父亲为旋转点左旋，结束
                - 左侄为红（包括全是红的）
                    - 兄弟在父亲的左侧
                        - 父亲的颜色给兄的，父亲变为黑色，左侄变为黑色，以父亲为旋转点右旋，结束
                    - 兄弟在父亲的右侧
                        - 兄弟变红，左侄变黑，以兄弟为旋转点右旋

### 多路平衡搜索树：B-Tree/B+Tree

#### B树

- 定义
    - M阶B树，就是M叉
    - 每个节点内的记录个数<=m-1
    - 根节点内的记录个数>=1
    - 其余节点内记录个数>=ceil(m/2)-1
    - 每个节点内的记录个数从左至右从小到大有序
    - 当前记录的左子树的值均能小于当前记录，右子树的值均大于当前记录
- 添加过程
    - 新来数据找到叶子节点插入
    - 叶子节点记录个数
        - <=m-1,结束
        - \>m-1,裂变
            - 中间节点上移到父亲层
                - 父亲层记录个数讨论
            - 左侧记录成为左子树
            - 右侧节点成为右子树
- 删除过程
    - 查找到记录，判断是否是叶子节点
        - 是下一步
        - 不是，进行记录替换
    - 删除记录
    - 讨论节点内记录个数
        - \>=ceil(m/2)-1,结束
        - <ceil(m/2)-1,看兄弟节点记录个数
            - \>ceil(m/2)-1,兄弟节点上移一个记录至父亲层，父亲层下移一个记录到当前层
            - =ceil(m/2)-1,父亲记录下移与当前节点，兄弟节点合并成一个节点，讨论父亲节点记录个数情况

#### B+树

- 定义
    - 有叶子节点(记录),索引(内部)节点
    - M阶B+有M叉
    - 根节点既可以是索引节点，也可以是叶子节点
    - 索引/记录个数<=m-1
    - 根节点索引/记录个数>=1
    - 其他节点内索引/记录个数>=ceil(m/2)-1
    - 每个节点内索引/记录从左到右从小到大有序
    - 当前记录/索引的右子树均小于他，左子树均大于他
    - 相邻叶子节点间有指针，从左向右指向
- 添加过程
    - 记录添加至叶子节点
    - 讨论叶子节点记录个数
        - 记录个数<=m-1,结束
        - 记录个数>m-1,裂变
            - 前m/2个成为左子，剩余记录成为右子，相邻叶子节点指针指向
            - 第m/2+1个记录的索引复制一份至父亲层
    - 讨论父亲层索引个数
        - <=m-1,结束
        - \>m-1裂变
            - 中间索引上移至父亲层，左侧索引为左子，右侧索引为右子
            - 再次讨论父亲层索引个数
- 删除过程
    - 在叶子节点内删除对应记录
    - 看叶子节点内记录个数
        - \>=ceil(m/2)-1,结束
        - <ceil(m/2)-1,看兄弟节点内记录个数
            - \>ceil(m/2)-1 兄弟记录移一个至当前节点更新父亲索引
            - =ceil(m/2)-1,合并当前节点与兄弟节点，删除父亲索引
            - 讨论父亲层索引个数
                - \>=ceil(m/2) - 1结束
                - <ceil(m/2) - 1看兄弟节点索引个数
                    - \>ceil(m/2) -1,兄弟上移一个至父亲层，父亲下移一个至当前结束
                    - =ceil(m/2) -1,父亲下移一个索引与当前节点和兄弟合并为一个新节点，讨论父亲层索引

- B和B+树的区别
    - 结构
        - B记录
        - B+叶子，索引；指针（叶子）
    - 增删
        - 因为B+的数据都在叶子，具体不同
    - 查
        - B：1~log(m,n)
        - B+:log(m,n)
            - B+树还可以范围搜索
                - 叶子上的指针与跳表差不多
                - 找打具体值，沿着指针能找到范围的数据

### 哈夫曼树：Haffman(最优二叉树)

- 叶子节点为带权节点，其他节点为辅助节点
- 只有度为0的和度为2的节点
- 带权路径长度 = WL
    - W(Weight):带权节点的权值/重
    - L，根到带权节点的路径长度
- WPL：所有带权节点WL和
- 最优二叉树
    - WPL最小的二叉树为最优二叉树(哈夫曼树)
- 哈夫曼树主要用于哈夫曼编码：进行无损压缩
- 树的创建
    - 带权节点按照权值排序
    - 最小的两个权值节点构成一个新的节点，该节点的权值为WPL(两个节点大小顺序固定)
    - 新节点与其他节点重新排序，重复以上动作直到剩余一个节点
- 哈夫曼编码
    - 哈夫曼树创建后，一般按照左边为0，右边为1的原则，从根到叶子路径上的01值为叶子节点的编码号
    - 哈夫曼树每个人创建都可能不一样
    - A：10，B15，C：40，D：30，E：5
    - 其中的一种编码：无前缀
        - A：1101
        - B：111
        - C：0
        - D：10
        - E：1100
    - 110100111
        - ACCB

### 博弈树：Game Tree

- 性质
    - 全信息
    - 非偶然
    - 零和
- 极大极小搜索树
    - 甲乙两人在1，2，3中选择一个数相加到计数板上，直到到达一百，此时到达的赢，甲先选
    - 列出选择的树，甲赢为1，乙赢为-1
    - 甲每次在孩子中选择对自己最有利的(最大值)，乙每次选择对甲最没有利的(最小值)
- α-β减
    - 甲选择时，左面大于零对甲有利，右面可以不应看，因为右面比最小，选左面，右面比左大，一定大于零
    - 乙选择时，左面小于零，右面同样

### 字典树：Trie Tree

- 查找，计数，排序
- 字典树不能为空树
- 字典树的每个节点内并不包含字符

## 图(Graph)

- 基础概念
    - G = (V,E)
        - V:顶点
        - E:边
    - 依附：边(V1,V2)依附于V1，V2
    - 完全图：所有可能存在的边都存在
        - 边的个数：C(n,2)
    - 有向连通图
        - 变得个数：A(n,2)
    - 路径：点到点，边
    - 简单路径：除起点终点可以相同，其他点不可以重复
    - 连通：有路径可通
    - 连通图：图中所有点均可有路径可通
        - n个顶点的无向图最少多少边能构成连通图
            - n-1
        - n个顶点的无向图最少多少边一定能构成连通图
            - C(n-1,2) + 1
    - 子图：顶点和边都属于一个图
    - 极大连通子图(连通分量)：连通图的话是图本身
    - 度：邻接了几个顶点
- 遍历
    - DFS
    - BFS
        - 判断二分图，指定一个为一个颜色，与他相连的为另一个颜色，按照BFS顺序，直到颜色冲突或者遍历完
- 二分图
    - 两个集合，集合内部不可指向
- 有向无环图(DAG)：解决课程表问题
    - 拓扑排序(序列)：为一个项目具备依赖关系的活动求得可执行的线性顺序（序列）也就是DAG
        - 可以将判断图是否成环
    - 模板
        - 统计顶点入度
        - 队列
        - 入度为0的顶点入队
        - 处理
            - 出队
            - 所有邻接点入度减一
            - 新的入度为0的顶点出队
- 迪杰斯特拉
    - 有向带权图求一个顶点到另一个顶点最短路径
    - 思想
        - 首先邻接矩阵，0为无边，其他为到达权值
        - 从起点开始，根据贪心，找到最小权值，下一站到位置(可以不到)
        - 根据到达的位置看这处可以到的位置，算出如果到的话，与不到的权值差，小的留下，已经到达的(选过的不用管，算没去过的)
        - 再次根据贪心找到最小的，然后重复上述步骤
- 最小生成树
    - 无向带权图中，所有成为连通图(所有点连上)最小的WPL，不能有环(不能有闭合回路)
    - 克鲁斯卡尔
        - 找到最小的边，然后继续找最小的，注意不能够成环，直到所有的顶点都在
    - prim普里姆
        - 随便找一个顶点，这个顶点散发数去找到邻接权值最小的，然后在找这两个顶点散发出去最小的，直到顶点都在